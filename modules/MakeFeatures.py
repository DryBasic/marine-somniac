import streamlit as st
import pandas as pd
from typing import Callable
import modules.instructions as instruct
from utils.EDF.EDF import EDFutils
from modules.ConfigureSession import SessionConfig
from config.channelcompute import *


class MakeFeatures(SessionConfig):
    def __init__(self, analysis) -> None:
        self.analysis = analysis
        self.output_freq = None
        self.edf = EDFutils(
            self.get_edf_from_analysis(),
            fetch_metadata=False,
            config=self.get_edfconfig() 
        )
        self.feature_config = {}
        self.config_name = "MakeFeatures.json"
        self.feature_data_name = "features.csv"
        self.containers = {}

    def configure_output_freq(self) -> None:
        self.output_freq = st.number_input(
            "Output frequency (Hz)",
            min_value=1,
            help=instruct.FEATURE_FREQUENCY_HELP
        )

    def specify_methods_per_channel(self) -> None:
        """
        Create expanders for each specified channel and let user specify which
        features should be computed from it. Modifies self.feature_config to contain
        all the specifications generated by the nested functions.
        """
        st.subheader("Specify first round calculations")
        channel_methods = {}
        for ch_name, ch_type in self.edf.channel_types.items():
            with st.expander(f"({ch_type}): {ch_name}", True):
                channel_methods[ch_name] = st.multiselect(
                    "Calculate features",
                    options=FEATURE_OPTIONS[ch_type],
                    key=f"{ch_name}-pick-derivatives"
                )
                m_cfgs = []
                for method_label in channel_methods[ch_name]:
                    method = FEATURE_OPTIONS['all'][method_label]
                    method_config = self.specify_method_instances(ch_name, method_label, method)
                    m_cfgs.append(method_config)
                self.feature_config[ch_name] = {k: v for cfg in m_cfgs for k, v in cfg.items()}

                validity = self.validate_channel_configuration(self.feature_config[ch_name])
                if not validity[0]:
                    st.error(validity[1])
                else:
                    st.success(validity[1])
                
    def specify_method_instances(self, ch_name:str, label:str, method:Callable, previous_derivand:list=None, previous_config:list=None) -> dict:
        method_name = method.__name__
        og_label = label

        if previous_derivand is None:
            previous_derivand = []
        if previous_config is None:
            method_config = []
        else:
            method_config = previous_config

        # Is the method configurable?
        if label in NOT_CONFIGURABLE:
            method_config.append({'args': None})
        else:
            # Is this a recursive call?
            if previous_derivand:
                label = f"{' '.join(previous_derivand)}: {og_label}"
            popover = st.popover(f"Configure {label}", use_container_width=True)

            # Is the method derivable?
            if not og_label in DERIVANDS:
                main_menu = popover.container()
            else:
                main_menu, deriv_menu = popover.tabs([f"{label}", f'{label} Derivatives'])
            
            n_instances = main_menu.number_input("How many instances?",
                    min_value=1,
                    key=f"{ch_name}{label}",
                    help=instruct.N_COMPS_HELP
                )
            main_menu.markdown(f"**Parameters for {og_label} Calculation**")
            for i in range(n_instances):
                deriv_config = {}
                main_menu.markdown(f"Instance {i+1}")
                method_args = self.specify_method_arguments(
                    main_menu, ch_name, method, label+str(i))

                if og_label in DERIVANDS:
                    deriv_menu.markdown(f"**Instance {i+1}{self.format_method_arg_labels(method_args)}**")
                    derivatives = deriv_menu.multiselect(
                        "Calculate features",
                        options=DERIVANDS[og_label],
                        key=f"{ch_name}{label}{i}"
                    )
                    for deriv in derivatives:
                        current_derivand = [f"{label} {i+1}"]
                        next_method = LABEL_TO_METHOD[deriv]
                        # recursive call
                        deriv_config = {'derived': self.specify_method_instances(
                            ch_name=ch_name,
                            label=deriv,
                            method=next_method,
                            previous_derivand=previous_derivand+current_derivand,
                            previous_config=method_config
                        )}

                method_config.append({
                    'args': method_args,
                    **deriv_config
                })
        return {method_name: method_config}
    
    def specify_method_arguments(self, container, ch_name, method, key_str='') -> dict:
        """
        Generate the widgets that allow the user to modify the parameters
        going into a feature computation. Sets defaults and gives argument
        descriptions by reading the method argspec and docstring.
        """
        method_name = method.__name__
        method_argspec = self.edf.get_method_args(ch_name, method_name)
        arg_names = method_argspec[0]
        arg_defaults = method_argspec[1]
        arg_descs = [self.extract_arg_desc_from_docstring(method.__doc__, arg)
                        for arg in arg_names]

        arg_vals = {}
        with container:
            c = st.columns(len(arg_names))
            for i, arg in enumerate(arg_names):
                arg_vals[arg] = c[i].text_input(
                    arg,
                    value=arg_defaults[i],
                    help=arg_descs[i],
                    key=f"{key_str}{ch_name}{method_name}{arg}"
                )
        return arg_vals

    def validate_channel_configuration(self, channel_config) -> tuple[bool, str]:
        if not channel_config:
            return (False, "No features specified. Either remove this channel from the main "
                    "configuration, or specify features to compute from this channel.")
        
        return (True, "Configuration valid")

    def validate_configuration(self) -> tuple[bool, str]:
        validities = []
        for channel_config in self.feature_config.values():
            validities.append(self.validate_channel_configuration(channel_config)[0])

        if not all(validities):
            return (False, "One or more channels have invalid configurations.")
        return (True, "All configurations valid. "
                "Saving this configuration will overwrite the previous.")
    
    # TODO
    def retrieve_configuration(self) -> dict:
        pass

    def save_configuration(self) -> None:
        self.write_configuration(
            analysis=self.analysis,
            config=self.feature_config,
            name=self.config_name
        )
        st.toast(f"Configuration saved.")

    # TODO
    def build_features(self):
        with st.spinner("Calculating features, this may take a while..."):
            pass
            # df.to_csv(f"{}/{self.feature_data_name}")
        st.toast("Features computed and saved to analysis.")

    @staticmethod
    def format_method_arg_labels(argdict: dict) -> str:

        def remove_chain(base_str: str, replacements: list):
            removed = base_str
            for r in replacements:
                removed = removed.replace(r, '') 
            return removed
        
        remove = ["'", '"', '{', '}']
        label = f": ({remove_chain(str(argdict), remove)})"
        return label

    @staticmethod
    def extract_arg_desc_from_docstring(doc_str: str, arg: str) -> str:
        """
        The docstrings of EDF.Channel, .EXGChannel, and .ECGChannel follow a specific
        format such that the description of an argument can be extracted with the following
        string operation.
        """
        if doc_str is not None:
            if arg in doc_str:
                desc = doc_str.split(f"{arg}:")[1].split('\n')[0]
                return desc
        else:
            return ''
    