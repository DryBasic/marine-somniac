import streamlit as st
import pandas as pd
import modules.instructions as instruct
from utils.EDF.EDF import EDFutils
from modules.ConfigureSession import SessionConfig
import config as cfg


class MakeFeatures(SessionConfig):
    def __init__(self, analysis) -> None:
        self.analysis = analysis
        self.output_freq = None
        self.edf = EDFutils(
            self.get_edf_from_analysis(),
            fetch_metadata=False,
            config=self.get_edfconfig() 
        )
        self.feature_config = {}

    def configure_(self) -> None:
        self.output_freq = st.number_input(
            "Output frequency (Hz)",
            min_value=1,
            help=instruct.FEATURE_FREQUENCY_HELP
        )
    
    def configure_channel_method(self, ch_name, computation, key_str='') -> dict:
        """
        Generate the widgets that allow the user to modify the parameters
        going into a feature computation. Sets defaults and gives argument
        descriptions by reading the method argspec and docstring.
        """
        method = cfg.FEATURE_OPTIONS['all'][computation]
        method_name = method.__name__
        method_argspec = self.edf.get_method_args(ch_name, method_name)
        arg_names = method_argspec[0]
        arg_defaults = method_argspec[1]
        arg_descs = [self.extract_arg_desc_from_docstring(method.__doc__, arg)
                      for arg in arg_names]

        arg_vals = {}
        c = st.columns(len(arg_names))
        for i, arg in enumerate(arg_names):
            arg_vals[arg] = c[i].text_input(
                arg,
                value=arg_defaults[i],
                help=arg_descs[i],
                key=f"{key_str}{ch_name}{computation}{arg}"
            )

        return arg_vals

    def computation_popover(self, ch_name, computation) -> dict:
        """
        Create a popover to contain the configuration of a feature computation.
        """
        comp_config = {'self': [], 'derivative': []}
        with st.popover(f"Configure {computation}", use_container_width=True):
            slf, drv = st.tabs([f"{computation}", f'{computation} Derivatives'])
            with slf:
                n = st.number_input("How many instances?",
                        min_value=1,
                        key=f"{ch_name}{computation}",
                        help=instruct.N_COMPS_HELP
                    )
                st.divider()
                st.markdown(f"**Parameters for {computation} Calculation**")
                for i in range(n):
                    st.markdown(f"Instance {i+1}")
                    comp_config['self'].append(
                        self.configure_channel_method(ch_name, computation, str(i))
                    )
                    
            with drv:
                derive_from = st.multiselect(
                    'Derive from',
                    options=cfg.FEATURE_OPTIONS['Other'],
                    key=f"{ch_name}{computation}deriv"
                )
            return comp_config

    def specify_computations(self) -> None:
        """
        Create expanders for each specified channel and let user specify which
        features should be computed from it. Modifies self.feature_config to contain
        all the specifications generated by the nested functions.
        """
        st.subheader("Specify first round calculations")
        compute = {}
        for ch_name, ch_type in self.edf.channel_types.items():
            self.feature_config[ch_name] = {}
            with st.expander(f"({ch_type}): {ch_name}", True):
                compute[ch_name] = st.multiselect(
                    "Calculate features",
                    options=cfg.FEATURE_OPTIONS[ch_type],
                    key=f"{ch_name}round1"
                )
                
                for comp in compute[ch_name]:
                    method = cfg.FEATURE_OPTIONS['all'][comp].__name__
                    self.feature_config[ch_name][method] = self.computation_popover(ch_name, comp)
                
                st.divider()

        st.write(self.feature_config)

    @staticmethod
    def format_method_arg_label(computation_name: str, args: dict) -> str:
        pass

    @staticmethod
    def extract_arg_desc_from_docstring(doc_str: str, arg: str) -> str:
        """
        The docstrings of EDF.Channel, .EXGChannel, and .ECGChannel follow a specific
        format such that the description of an argument can be extracted with the following
        string operation.
        """
        desc = doc_str.split(f"{arg}:")[1].split('\n')[0]
        return desc